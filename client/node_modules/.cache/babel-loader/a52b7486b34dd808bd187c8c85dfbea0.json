{"ast":null,"code":"const fetch = require('node-fetch');\n\nconst Constants = require('./util/Constants');\n\nclass Request {\n  constructor(youtube) {\n    this.youtube = youtube;\n  }\n  /**\n   * Make a request to the YouTube API\n   * @param {string} endpoint The endpoint to query\n   * @param {object} [qs={}] Query strings\n   * @returns {Promise<object>}\n   */\n\n\n  make(endpoint, qs = {}) {\n    qs = Object.assign({\n      key: this.youtube.key\n    }, qs);\n    const params = Object.keys(qs).filter(k => qs[k]).map(k => `${k}=${qs[k]}`);\n    return fetch(encodeURI(`https://www.googleapis.com/youtube/v3/${endpoint}${params.length ? `?${params.join('&')}` : ''}`)).then(result => result.json()).then(result => {\n      if (result.error) return Promise.reject(result.error);\n      return result;\n    });\n  }\n  /**\n   * Get a resource from the YouTube API\n   * @param {string} type The type of resource to get\n   * @param {object} [qs={}] Any other query options\n   * @returns {Promise<object>}\n   */\n\n\n  getResource(type, qs = {}) {\n    qs = Object.assign({\n      part: Constants.PARTS[type]\n    }, qs);\n    return this.make(Constants.ENDPOINTS[type], qs).then(result => result.items.length ? result.items[0] : Promise.reject(new Error(`resource ${result.kind} not found`)));\n  }\n  /**\n   * Get a resource from the YouTube API, by ID\n   * @param {string} type The type of resource to get\n   * @param {string} id The ID of the resource to get\n   * @param {object} [qs={}] Any other query options\n   * @returns {Promise<object>}\n   */\n\n\n  getResourceByID(type, id, qs = {}) {\n    return this.getResource(type, Object.assign(qs, {\n      id\n    }));\n  }\n  /**\n   * Get a video from the YouTube API\n   * @param {string} id The video to get\n   * @param {object} [options] Any request options\n   * @returns {Promise<object>}\n   */\n\n\n  getVideo(id, options) {\n    return this.getResourceByID('Videos', id, options);\n  }\n  /**\n   * Get a playlist from the YouTube API\n   * @param {string} id The playlist to get\n   * @param {object} [options] Any request options\n   * @returns {Promise<object>}\n   */\n\n\n  getPlaylist(id, options) {\n    return this.getResourceByID('Playlists', id, options);\n  }\n  /**\n   * Get a channel from the YouTube API\n   * @param {string} id The channel to get\n   * @param {object} [options] Any request options\n   * @returns {Promise<object>}\n   */\n\n\n  getChannel(id, options) {\n    return this.getResourceByID('Channels', id, options);\n  }\n  /**\n   * Fetch a paginated resource.\n   * @param {string} endpoint The endpoint to query.\n   * @param {number} [count=Infinity] How many results to retrieve.\n   * @param {Object} [options={}] Additional options to send.\n   * @param {Array} [fetched=[]] Previously fetched resources.\n   * @param {?string} [pageToken] The page token to retrieve.\n   * @returns {Promise<Array<object>>}\n   */\n\n\n  getPaginated(endpoint, count = Infinity, options = {}, fetched = [], pageToken = null) {\n    if (count < 1) return Promise.reject('Cannot fetch less than 1.');\n    const limit = count > 50 ? 50 : count;\n    return this.make(endpoint, Object.assign(options, {\n      pageToken,\n      maxResults: limit\n    })).then(result => {\n      const results = fetched.concat(result.items);\n      if (result.nextPageToken && limit !== count) return this.getPaginated(endpoint, count - limit, options, results, result.nextPageToken);\n      return results;\n    });\n  }\n\n}\n\nmodule.exports = Request;","map":{"version":3,"sources":["E:/MoodyPlayer/client/node_modules/simple-youtube-api/src/Request.js"],"names":["fetch","require","Constants","Request","constructor","youtube","make","endpoint","qs","Object","assign","key","params","keys","filter","k","map","encodeURI","length","join","then","result","json","error","Promise","reject","getResource","type","part","PARTS","ENDPOINTS","items","Error","kind","getResourceByID","id","getVideo","options","getPlaylist","getChannel","getPaginated","count","Infinity","fetched","pageToken","limit","maxResults","results","concat","nextPageToken","module","exports"],"mappings":"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","sourcesContent":["const fetch = require('node-fetch');\nconst Constants = require('./util/Constants');\n\nclass Request {\n    constructor(youtube) {\n        this.youtube = youtube;\n    }\n\n    /**\n     * Make a request to the YouTube API\n     * @param {string} endpoint The endpoint to query\n     * @param {object} [qs={}] Query strings\n     * @returns {Promise<object>}\n     */\n    make(endpoint, qs = {}) {\n        qs = Object.assign({ key: this.youtube.key }, qs);\n        const params = Object.keys(qs).filter(k => qs[k]).map(k => `${k}=${qs[k]}`);\n        return fetch(encodeURI(`https://www.googleapis.com/youtube/v3/${endpoint}${params.length ? `?${params.join('&')}` : ''}`))\n            .then(result => result.json())\n            .then(result => {\n                if (result.error) return Promise.reject(result.error);\n                return result;\n            });\n    }\n\n    /**\n     * Get a resource from the YouTube API\n     * @param {string} type The type of resource to get\n     * @param {object} [qs={}] Any other query options\n     * @returns {Promise<object>}\n     */\n    getResource(type, qs = {}) {\n        qs = Object.assign({ part: Constants.PARTS[type] }, qs);\n        return this.make(Constants.ENDPOINTS[type], qs).then(result =>\n            result.items.length ? result.items[0] : Promise.reject(new Error(`resource ${result.kind} not found`))\n        );\n    }\n\n    /**\n     * Get a resource from the YouTube API, by ID\n     * @param {string} type The type of resource to get\n     * @param {string} id The ID of the resource to get\n     * @param {object} [qs={}] Any other query options\n     * @returns {Promise<object>}\n     */\n    getResourceByID(type, id, qs = {}) {\n        return this.getResource(type, Object.assign(qs, { id }));\n    }\n\n    /**\n     * Get a video from the YouTube API\n     * @param {string} id The video to get\n     * @param {object} [options] Any request options\n     * @returns {Promise<object>}\n     */\n    getVideo(id, options) {\n        return this.getResourceByID('Videos', id, options);\n    }\n\n    /**\n     * Get a playlist from the YouTube API\n     * @param {string} id The playlist to get\n     * @param {object} [options] Any request options\n     * @returns {Promise<object>}\n     */\n    getPlaylist(id, options) {\n        return this.getResourceByID('Playlists', id, options);\n    }\n\n    /**\n     * Get a channel from the YouTube API\n     * @param {string} id The channel to get\n     * @param {object} [options] Any request options\n     * @returns {Promise<object>}\n     */\n    getChannel(id, options) {\n        return this.getResourceByID('Channels', id, options);\n    }\n\n    /**\n     * Fetch a paginated resource.\n     * @param {string} endpoint The endpoint to query.\n     * @param {number} [count=Infinity] How many results to retrieve.\n     * @param {Object} [options={}] Additional options to send.\n     * @param {Array} [fetched=[]] Previously fetched resources.\n     * @param {?string} [pageToken] The page token to retrieve.\n     * @returns {Promise<Array<object>>}\n     */\n    getPaginated(endpoint, count = Infinity, options = {}, fetched = [], pageToken = null) {\n        if(count < 1) return Promise.reject('Cannot fetch less than 1.');\n\n        const limit = count > 50 ? 50 : count;\n        return this.make(endpoint, Object.assign(options, { pageToken, maxResults: limit })).then(result => {\n            const results = fetched.concat(result.items);\n            if(result.nextPageToken && limit !== count) return this.getPaginated(endpoint, count - limit, options, results, result.nextPageToken);\n            return results;\n        });\n    }\n}\n\nmodule.exports = Request;\n"]},"metadata":{},"sourceType":"script"}